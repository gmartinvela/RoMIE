import sys
import time
import os
import subprocess
import webbrowser
import threading
import traceback

from django.http import HttpResponse
from django.shortcuts import render
from robot_control.models import Category, Question, Response
import json

MAX_TIME = 8 # seconds
PORT = '8000'
GLOBAL_LOCK = threading.Lock()

try:
    from robot_app.joystick_handler import get_event
    Joystick=True
except:
    Joystick=False
    print 'The joystick is not working'

# ############ -  Bluetooth Initialization  - ###############
try:
    import bluetooth #For GNU/Linux using PyBluez
    #import lightblue #For Mac OS X using lightblue
    #sys.path.append('/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC') #For Mac OS X using lightblue
    BT_name = "linvor"
    BT_address = '00:12:02:09:05:16'
    #nearby_devices = bluetooth.discover_devices()
    BT_port = 1
    #Client Socket
    client_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM) #For GNU/Linux using PyBluez
    #client_sock = lightblue.socket()
    port = client_sock.connect((BT_address, BT_port))
    BT_available=True
except:
    BT_available=False
    print 'No Bluetooth device is available'

def wait_ack(client_sock):
    total_received = "" 
    while 'ACK' not in total_received:
        total_received += client_sock.recv(1024)

    print repr(total_received)

    return total_received

def forward(request):
    if request.META.get('REMOTE_ADDR') not in ('127.0.0.1', 'localhost', '::1', '127.0.1.1'):
        return HttpResponse("INVALID_CLIENT_ADDRESS")
    client_sock.send('F')
    response = wait_ack(client_sock)
    return HttpResponse(response)

def turn_left(request):
    if request.META.get('REMOTE_ADDR') not in ('127.0.0.1', 'localhost', '::1', '127.0.1.1'):
        return HttpResponse("INVALID_CLIENT_ADDRESS")
    client_sock.send('L')
    response = wait_ack(client_sock)
    return HttpResponse(response)

def turn_right(request):
    if request.META.get('REMOTE_ADDR') not in ('127.0.0.1', 'localhost', '::1', '127.0.1.1'):
        return HttpResponse("INVALID_CLIENT_ADDRESS")
    client_sock.send('R')
    response = wait_ack(client_sock)
    print response 
    return HttpResponse(response)

def sensor_wall(request):
    if request.META.get('REMOTE_ADDR') not in ('127.0.0.1', 'localhost', '::1', '127.0.1.1'):
        return HttpResponse("INVALID_CLIENT_ADDRESS")
    client_sock.send('S')
    response = client_sock.recv(1024)
    #TODO: recibir lectura del sensor  
    #return HttpResponse(response)
    print "response ",response 
    return HttpResponse(int(response))

HEADER_CODE = """
import urllib2

OPENER = urllib2.build_opener(urllib2.ProxyHandler({}))

def forward():
    return OPENER.open("http://localhost:%(port)s/RoMIE/movements/forward").read()

def turn_left():
    return OPENER.open("http://localhost:%(port)s/RoMIE/movements/turn_left").read()

def turn_right():
    return OPENER.open("http://localhost:%(port)s/RoMIE/movements/turn_right").read()

def sensor_wall():
    print "other response",OPENER.open("http://localhost:%(port)s/RoMIE/movements/sensor_wall").read()
    return OPENER.open("http://localhost:%(port)s/RoMIE/movements/sensor_wall").read()


""" % { 'port' : PORT }

def move(direction):
    client_sock.send(direction)
    response = client_sock.recv(1024)
    
#     #print "direction: %s" % direction
#     #print "response: %s" % response
#     string_tag_position = response.find("Tag")
#     if string_tag_position != -1:
#         in_tag_position = string_tag_position + 5
#         out_tag_position = in_tag_position + 15
#         tag = response[in_tag_position:out_tag_position]
#         tag_full = tag.replace(" ", "")
#         print tag_full
#         os.chdir("/home/gustavo/Desktop")
#         if tag_full == "4F00569F08":
#             #webbrowser.open("http://127.0.0.1:8000/RoMIE/question_son_goku/", new = 0)
#             subprocess.call(["java","-jar","Pregunton.jar","1"])
#         elif tag_full == "4F0088ABCB":
#             #webbrowser.open("http://127.0.0.1:8000/RoMIE/question_one_piece/", new = 0)
#             subprocess.call(["java","-jar","Pregunton.jar","2"])
#         elif tag_full == "50008967FC":
#             #webbrowser.open("http://127.0.0.1:8000/RoMIE/question_digimon/", new = 0)
#             subprocess.call(["java","-jar","Pregunton.jar","3"])
#         elif tag_full == "4F00568090":
#             #webbrowser.open("http://127.0.0.1:8000/RoMIE/question_naruto/", new = 0)
#             subprocess.call(["java","-jar","Pregunton.jar","4"])
# #     #    return tag    
# ############################################################

def index(request):
    #return HttpResponse("Hello, world. You're at the category index.")
    if request.method == 'GET':
        return render(request, 'robot_control/index.html')
    elif request.method == 'POST':
        received_command = request.REQUEST["command"]
        #print received_command
        if BT_available==True:
            move(received_command)
        else:
            print 'Cannot send command to the robot.'
        #tag = move(received_command)
        #if tag:
        #    print tag
        return HttpResponse("POST OK")

def joystick_status(request):
    if Joystick==True:
        return HttpResponse(json.dumps(get_event()))
    else:
        return HttpResponse('No Joystick')
    
def tutorial(request):
    return render(request, 'robot_control/tutorial.html')

def blockly(request):
    if request.method == 'GET':
        return render(request, 'robot_control/blockly.html')
    elif request.method == 'POST':
        block_code = request.REQUEST["code"]
        
        launch_in_background(block_code) 

        return render(request, 'robot_control/blockly.html')

def launch_in_background(block_code):
    t = threading.Thread(target=exec_code, args = (block_code,))
    t.start()

def exec_code(code):
    final_code = HEADER_CODE + code
    try:
        with GLOBAL_LOCK:
            print final_code
            #exec final_code
            open("executable.py", "w").write(final_code)
            print "final_code ",final_code
            popen = subprocess.Popen([sys.executable, "executable.py"])
            initial_time = time.time()
                
            while time.time() < (initial_time + MAX_TIME):
                if popen.poll() is not None:
                    break
                time.sleep(1)
            
            if popen.poll() is None:
                print "Killing in the name of", (time.time() - initial_time)
                sys.stdout.flush()
                popen.terminate()
                popen.kill()
    except:
        traceback.print_exc()
        return HttpResponse("OH, FUCK")


def quiz(request):
    return render(request, 'robot_control/quiz.html')

#######################################################################################################################################

